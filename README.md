# SIAM Student Programming Competition 2023

Welcome to my submission for the SIAM Student Programming Competition 2023. This project revolves around simulating an Automated Market Maker (AMM) and exploring strategies for liquidity provision and trading within this framework.

Automated Market Makers are algorithms used in decentralized finance to facilitate token swaps without relying on traditional order books. They use mathematical formulas to price assets based on supply and demand. In this project, I modeled an AMM that allows swapping between two tokens and provides functionalities for liquidity providers to mint and burn liquidity tokens. The aim was to simulate market dynamics, develop strategies for liquidity provision, and analyze performance and risk.

To accomplish this, I completed the implementation of an AMM model in Python, incorporating core functionalities like token swapping, liquidity minting and burning, and simulation of market events. An evolutionary optimization algorithm was developed to enhance the AMM's parameters for better performance, focusing on maximizing returns and minimizing risk. A Jupyter notebook was created to test and visualize the results, including plots of reserves, prices, and performance metrics.

The main components of the project include:

- **`amm.py`**: Defines the `amm` class, modeling the AMM's behavior with methods for swapping tokens, handling liquidity operations, and simulating market events.
- **`evolution.py`**: Implements an evolutionary strategy algorithm to optimize parameters of the AMM model.
- **`test_notebook.ipynb`**: A Jupyter notebook for testing the implementation and visualizing simulation results.
- **`params.py`**: Contains parameters used in simulations and optimizations.

### Evolutionary Strategy in `evolution.py`

The `evolution.py` script implements an evolutionary optimization algorithm designed to find optimal strategies for liquidity provision in the AMM model. The goal is to determine the initial allocation of tokens across multiple pools that maximizes returns while controlling for risk, specifically by minimizing the Conditional Value at Risk (CVaR).

The evolutionary strategy works as follows:

- **Initialization**: A population of candidate solutions (`Theta` instances) is created, each representing a different initial allocation of tokens (`xs_0`) across the AMM pools.
- **Evaluation**: Each candidate solution is evaluated by simulating the AMM's performance over time using the `simulate` method from `amm.py`. The fitness of a solution is determined by calculating the CVaR of the log returns from the simulations.
- **Selection**: Candidates with the best fitness scores (lowest CVaR) are selected to form a new population.
- **Mutation**: New candidate solutions are generated by adding small random changes to the selected candidates' parameters (`xs_0`). This introduces variability and explores new potential solutions.
- **Iteration**: The process of evaluation, selection, and mutation repeats over a number of generations, progressively improving the solutions.

By iteratively refining the strategies, the algorithm seeks to balance the trade-off between maximizing expected returns and minimizing downside risk. This approach aligns with the objectives outlined in the problem statement, where the task is to optimize the liquidity provision strategy in the AMM to achieve better performance under simulated market conditions.

### Usage

To utilize the project:

- **Initialize the AMM**: Set up the pools with desired parameters in `amm.py`.
- **Simulate Trades**: Use the `simulate` method to mimic trading activities over a specified time horizon.
- **Perform Token Swaps**: Call `swap_x_to_y` or `swap_y_to_x` to execute token swaps within the AMM.
- **Manage Liquidity**: Use `mint` to add liquidity and `burn` to remove it, receiving the underlying tokens.
- **Optimize Parameters**: Run `evolutionary_strategy` in `evolution.py` to optimize AMM parameters.
- **Visualize Results**: Open `test_notebook.ipynb` to visualize the simulation outcomes, including reserves, prices, and performance metrics.

### Visualization

The Jupyter notebook provides visualizations of the simulation results:

- **Reserves and Prices**: Plots showing token reserves and marginal prices over time to understand market dynamics.
- **Performance Metrics**: Histograms and statistics like mean returns and standard deviation.
- **Risk Analysis**: Calculation and visualization of Conditional Value at Risk (CVaR) and other risk metrics.